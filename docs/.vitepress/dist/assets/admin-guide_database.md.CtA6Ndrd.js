import{_ as n}from"./chunks/sql-schema.mxQQ8oCc.js";import{_ as t,c as i,o as r,ag as a}from"./chunks/framework.dvv-DFtf.js";const s="/assets/crdt.CZLDzoJd.svg",l="/assets/cr-sqlite-arch.7ou62ngN.svg",o="/assets/sync-db.Ail9lVWT.svg",f=JSON.parse('{"title":"Betrieb & Datenbank","description":"","frontmatter":{},"headers":[],"relativePath":"admin-guide/database.md","filePath":"admin-guide/database.md","lastUpdated":1768060888000}'),d={name:"admin-guide/database.md"};function c(u,e,h,g,b,p){return r(),i("div",null,[...e[0]||(e[0]=[a('<h1 id="betrieb-datenbank" tabindex="-1">Betrieb &amp; Datenbank <a class="header-anchor" href="#betrieb-datenbank" aria-label="Permalink to &quot;Betrieb &amp; Datenbank&quot;">​</a></h1><p>FMB Log speichert alle Daten in einer einzelnen SQLite‑Datei. Dadurch ist kein Datenbankserver notwendig und die Anwendung kann auch offline betrieben werden.</p><h2 id="standard‐datenbankpfad" tabindex="-1">Standard‑Datenbankpfad <a class="header-anchor" href="#standard‐datenbankpfad" aria-label="Permalink to &quot;Standard‑Datenbankpfad&quot;">​</a></h2><p>Standardmäßig liegt die Datenbank im Programmordner unter <code>resources/fmblog.db</code>. Beim ersten Start legt die Anwendung das Unterverzeichnis <code>resources</code> an (falls es fehlt) und erstellt die Datenbankdatei beim Öffnen automatisch.</p><p>Dieser Standard ist bewusst gewählt: Die Datenbank ist damit leicht auffindbar, einfach zu sichern und kann (sofern gewünscht) auch auf einen gemeinsam genutzten Pfad gelegt werden.</p><h2 id="stub‐db-und-updates" tabindex="-1">Stub‑DB und Updates <a class="header-anchor" href="#stub‐db-und-updates" aria-label="Permalink to &quot;Stub‑DB und Updates&quot;">​</a></h2><p>Für Neuinstallationen oder Updates kann eine <strong>Stub‑Datenbank</strong> mitgeliefert werden. Beim ersten Start wird dann (falls noch keine Datenbank existiert) <code>resources/fmblog.stub.db</code> aus den gebündelten Ressourcen nach <code>resources/fmblog.db</code> kopiert.</p><p>Wichtig: Eine vorhandene Datenbank wird dabei <strong>niemals überschrieben</strong>. Damit bleiben Bestandsdaten bei Updates erhalten.</p><h2 id="datenmodell-er" tabindex="-1">Datenmodell (ER) <a class="header-anchor" href="#datenmodell-er" aria-label="Permalink to &quot;Datenmodell (ER)&quot;">​</a></h2><p>Eine vereinfachte Darstellung des SQL-Schemas als ER-Diagramm finden Sie hier:</p><p><img src="'+n+'" alt="SQL-Schema (ER)"></p><h2 id="netzlaufwerk-und-mehrbenutzer" tabindex="-1">Netzlaufwerk und Mehrbenutzer <a class="header-anchor" href="#netzlaufwerk-und-mehrbenutzer" aria-label="Permalink to &quot;Netzlaufwerk und Mehrbenutzer&quot;">​</a></h2><p>SQLite kann grundsätzlich auf Netzlaufwerken funktionieren, allerdings hängt die Stabilität stark von Dateisperren/Locking, SMB‑Konfiguration (z. B. OpLocks) und der Latenz/Zuverlässigkeit des Shares ab. In Mehrbenutzer‑Szenarien kommt es typischerweise nicht auf „viele Leser“, sondern auf <strong>gleichzeitige Schreibzugriffe</strong> an.</p><p>Empfehlung: Validieren Sie den Mehrbenutzerbetrieb zunächst in einer Testumgebung und definieren Sie organisatorisch, wer wann Änderungen schreibt (z. B. Import zentral, Auswertung verteilt). Wenn regelmäßig Sperren oder Zeitüberschreitungen auftreten, ist ein lokaler DB‑Pfad pro Nutzer die robustere Variante.</p><h2 id="synchronisation-hub‐db-und-lokale-replica" tabindex="-1">Synchronisation (Hub‑DB und lokale Replica) <a class="header-anchor" href="#synchronisation-hub‐db-und-lokale-replica" aria-label="Permalink to &quot;Synchronisation (Hub‑DB und lokale Replica)&quot;">​</a></h2><p>Für den Mehrnutzerbetrieb nutzt FMB Log eine <strong>lokale Replica‑DB</strong> (pro Windows‑Benutzer) und synchronisiert diese regelmäßig mit einer <strong>Hub‑DB</strong> (z. B. im gemeinsamen Datenordner / Netzlaufwerk):</p><ul><li><strong>Hub‑DB:</strong> entspricht dem in den Einstellungen gesetzten DB‑Pfad (oder dem Standard unter <code>resources/fmblog.db</code>)</li><li><strong>Lokale Replica:</strong> wird im Benutzerprofil unter <code>AppData/Local/&lt;app-id&gt;/replicas/…</code> angelegt</li><li><strong>Sync:</strong> läuft automatisch (z. B. beim Fokuswechsel und alle ~10 s)</li></ul><h3 id="warum-lokale-replica-crdt" tabindex="-1">Warum lokale Replica + CRDT? <a class="header-anchor" href="#warum-lokale-replica-crdt" aria-label="Permalink to &quot;Warum lokale Replica + CRDT?&quot;">​</a></h3><p>Ein reiner SQLite‑Mehrbenutzerbetrieb über ein Netzlaufwerk ist oft fragil (Dateisperren, OpLocks, Latenz). Die Replica‑Architektur reduziert dieses Risiko deutlich:</p><ul><li><strong>Offline‑fähig:</strong> Die Anwendung bleibt auch bei temporär nicht verfügbarem Hub nutzbar (Arbeit in der lokalen Replica).</li><li><strong>Weniger Lock‑Druck auf dem Share:</strong> Nutzer schreiben hauptsächlich lokal; der Hub wird kurz/periodisch synchronisiert.</li><li><strong>Konfliktbehandlung:</strong> Gleichzeitige Änderungen können deterministisch zusammengeführt werden (CRDT/CR‑SQLite).</li></ul><p><img src="'+s+'" alt="Local‑First / CRDT (Übersicht)"></p><h3 id="wie-funktioniert-cr‐sqlite-crr-in-fmb-log" tabindex="-1">Wie funktioniert CR‑SQLite (CRR) in FMB Log? <a class="header-anchor" href="#wie-funktioniert-cr‐sqlite-crr-in-fmb-log" aria-label="Permalink to &quot;Wie funktioniert CR‑SQLite (CRR) in FMB Log?&quot;">​</a></h3><p>FMB Log verwendet CR‑SQLite, um Tabellen als <strong>CRR (Conflict‑free Replicated Relations)</strong> zu betreiben. Vereinfacht:</p><ul><li>Jede DB‑Instanz hat eine eigene <strong>Site‑ID</strong>.</li><li>Änderungen werden von CR‑SQLite als <strong>Change‑Events</strong> erfasst (<code>crsql_changes</code>).</li><li>Beim Sync werden neue Change‑Events zwischen lokaler Replica und Hub ausgetauscht und angewendet.</li></ul><p>Wichtig: Das Ergebnis ist <strong>eventual consistency</strong>. Nach erfolgreichem Sync konvergieren alle Replicas (deterministisch) auf denselben Zustand – ohne dass die Anwendung dazu File‑Locks “manuell” koordinieren muss.</p><p><img src="'+l+'" alt="cr‑sqlite Architektur"></p><h3 id="sync‐ablauf-automatisch" tabindex="-1">Sync‑Ablauf (automatisch) <a class="header-anchor" href="#sync‐ablauf-automatisch" aria-label="Permalink to &quot;Sync‑Ablauf (automatisch)&quot;">​</a></h3><p>Der Sync läuft automatisch und “best effort”:</p><ul><li>Beim Start wird ein initialer Sync versucht.</li><li>Zusätzlich bei Fokuswechsel (zurück zur App) und periodisch alle ~10 s.</li><li>Technisch werden erst <strong>Änderungen aus dem Hub in die lokale Replica gezogen</strong> (Pull) und danach <strong>lokale Änderungen in den Hub geschrieben</strong> (Push).</li></ul><p><img src="'+o+'" alt="Sync‑Prozess"></p><h3 id="einschrankungen-wichtig" tabindex="-1">Einschränkungen (wichtig) <a class="header-anchor" href="#einschrankungen-wichtig" aria-label="Permalink to &quot;Einschränkungen (wichtig)&quot;">​</a></h3><p>Auch mit CRDT/CR‑SQLite gibt es Grenzen und “Betriebsregeln”:</p><ol><li><p><strong>Konflikte sind möglich (und werden aufgelöst)</strong><br> Wenn zwei Nutzer <em>dieselbe</em> Entität gleichzeitig bearbeiten, greift eine deterministische Merge‑Regel. In der Praxis bedeutet das oft “Last‑Write‑Wins” auf Feld‑/Zellenebene.<br> Empfehlung: Kritische Stammdaten (FGW/NV/FMK) organisatorisch nur durch wenige Key‑User ändern lassen.</p></li><li><p><strong>Schema‑Constraints für CRR‑Tabellen</strong><br> CR‑SQLite stellt Anforderungen an das Schema (u. a. nicht‑nullable Primary Keys; keine <code>NOT NULL</code>‑Spalten ohne Default‑Wert).<br> Daraus folgt: IDs sind in FMB Log als <strong>stabile, eindeutige TEXT‑IDs</strong> ausgelegt (statt Auto‑Increment), und Schema‑Änderungen erfolgen über App‑Migrations.</p></li><li><p><strong>Netzwerk‑/Share‑Qualität bleibt entscheidend</strong><br> Der Hub ist weiterhin eine SQLite‑Datei. Wenn das Share instabil ist (Locking, hohe Latenz), kann es trotz Replica‑Ansatz zu Sync‑Fehlern kommen. Die App bleibt dann lokal nutzbar, aber Änderungen können erst später verteilt werden.</p></li><li><p><strong>Große BLOBs kosten Sync‑Zeit</strong><br> Messprotokolle werden bewusst <strong>nicht</strong> als BLOB in der CRDT‑SQLite synchronisiert. Stattdessen werden sie zstd‑komprimiert in einem Protokoll‑Archiv <strong>neben der Hub‑DB</strong> gespeichert und in der DB nur referenziert (BLAKE3, Archivdatei, Offset/Länge, optional <code>dict_id</code>).<br> Ergebnis: Der CR‑SQLite‑Sync bleibt schnell, weil er nur Metadaten synchronisiert.</p><p><strong>Ablage im Hub‑Ordner (neben <code>&lt;db&gt;.db</code>)</strong>:</p><ul><li><code>protocols/&lt;site-id-hex&gt;/pack-*.bin</code> (Packfiles, append‑only; max. ~100 Einträge oder ~1 MB pro Pack)</li><li><code>protocols/&lt;site-id-hex&gt;/state.json</code> (merkt sich das aktuelle Packfile)</li><li>DB‑Referenzen in <code>measurement_protocols</code> (<code>pack_file</code>, <code>pack_offset</code>, <code>pack_length</code>, <code>blake3</code>, <code>dict_id</code>, …)</li><li>Hinweis: Die Spalte <code>sha256</code> existiert nur für Abwärtskompatibilität und ist für neue Imports i. d. R. leer (maßgeblich ist <code>blake3</code>).</li></ul><p><strong>Offline‑Import:</strong> Wenn der Hub nicht erreichbar ist, wird das Protokoll im <strong>lokalen Cache</strong> abgelegt und die DB enthält zunächst eine „ausstehende“ Referenz (<code>pack_file=&#39;&#39;</code>, <code>pack_length=0</code>). Zusätzlich wird lokal eine Outbox geführt (<code>protocol_upload_outbox</code>), die Upload‑Versuche, Backoff und Fehlerstatus verwaltet (Status ist auf der Import‑Seite in „Ausstehende Uploads“ sichtbar). Nach dem nächsten erfolgreichen Sync lädt der importierende Client das Protokoll automatisch in das Hub‑Archiv hoch und aktualisiert die Referenz. Bis dahin können andere Clients die Messung sehen, das Protokoll aber noch nicht öffnen.</p></li></ol><h3 id="besonderheit-vault‐dateien-sind-nicht-teil-der-db‐synchronisation" tabindex="-1">Besonderheit: Vault‑Dateien sind nicht Teil der DB‑Synchronisation <a class="header-anchor" href="#besonderheit-vault‐dateien-sind-nicht-teil-der-db‐synchronisation" aria-label="Permalink to &quot;Besonderheit: Vault‑Dateien sind nicht Teil der DB‑Synchronisation&quot;">​</a></h3><p>Passwörter und Signierschlüssel werden zusätzlich in <strong>Stronghold‑Vaults</strong> gespeichert:</p><ul><li>Nutzer‑Vaults: <code>vaults/&lt;user_id&gt;.vault</code></li><li>Integritäts‑Vault: <code>vaults/&lt;db&gt;.integrity.vault</code></li></ul><p>Diese Dateien liegen <strong>neben der Hub‑DB</strong> im gemeinsamen Datenordner und werden <strong>nicht</strong> über die DB‑Synchronisation repliziert. Daher gilt:</p><ul><li>Kritische Admin‑Operationen (Benutzer-/Gruppen-/Rechteverwaltung, Integritätsschlüssel) sollten nur durchgeführt werden, wenn der Hub‑Pfad erreichbar ist.</li><li>Wenn der Hub‑Pfad nicht erreichbar ist, sind diese Aktionen in der UI deaktiviert (die Fach‑/Messdaten können weiterhin über die lokale Replica bearbeitet werden).</li></ul><h2 id="backup" tabindex="-1">Backup <a class="header-anchor" href="#backup" aria-label="Permalink to &quot;Backup&quot;">​</a></h2><p>Die sicherste Backup‑Strategie ist, die relevanten Dateien zu kopieren, wenn die Anwendung geschlossen ist. Für den Betrieb empfiehlt sich eine regelmäßige Sicherung (z. B. täglich) und eine Aufbewahrung mehrerer Generationen (Rotation), damit auch ältere Tagesabrechnungen nachvollziehbar bleiben.</p><p>Sichern Sie im Hub‑Ordner mindestens:</p><ul><li>die DB‑Datei (<code>&lt;db&gt;.db</code> bzw. <code>fmblog.db</code>)</li><li>den Ordner <code>protocols/</code> (Protokoll‑Archive/Packfiles)</li><li>den Ordner <code>vaults/</code> (Stronghold‑Vaults für Pepper/Integritätsschlüssel)</li></ul><div class="info custom-block"><p class="custom-block-title">Zusammenfassung (Datenbank)</p><ul><li>Eine Datei: SQLite <code>resources/fmblog.db</code> (Standardpfad).</li><li>Optional: Stub‑DB <code>resources/fmblog.stub.db</code> wird nur kopiert, wenn noch keine DB existiert.</li><li>Netzlaufwerke sind möglich, aber lock-/latency‑abhängig → vorher testen.</li><li>Mehrnutzerbetrieb: lokale Replica + CR‑SQLite Sync (eventual consistency).</li><li>Protokolle liegen als Packfiles im Hub‑Ordner (<code>protocols/…</code>), nicht als BLOB in der DB.</li><li>Backups am besten bei geschlossener Anwendung.</li></ul></div>',43)])])}const S=t(d,[["render",c]]);export{f as __pageData,S as default};
