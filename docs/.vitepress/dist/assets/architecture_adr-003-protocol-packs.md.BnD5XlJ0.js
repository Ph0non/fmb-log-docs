import{_ as i,c as r,o as n,ag as t}from"./chunks/framework.dvv-DFtf.js";const g=JSON.parse('{"title":"ADR‑003: Messprotokolle als Packfiles","description":"","frontmatter":{},"headers":[],"relativePath":"architecture/adr-003-protocol-packs.md","filePath":"architecture/adr-003-protocol-packs.md","lastUpdated":1768167711000}'),o={name:"architecture/adr-003-protocol-packs.md"};function l(a,e,s,c,d,h){return n(),r("div",null,[...e[0]||(e[0]=[t('<h1 id="adr‐003-messprotokolle-als-packfiles" tabindex="-1">ADR‑003: Messprotokolle als Packfiles <a class="header-anchor" href="#adr‐003-messprotokolle-als-packfiles" aria-label="Permalink to &quot;ADR‑003: Messprotokolle als Packfiles&quot;">​</a></h1><ul><li><strong>Status:</strong> angenommen</li><li><strong>Datum:</strong> 2026‑01‑11</li></ul><h2 id="kontext" tabindex="-1">Kontext <a class="header-anchor" href="#kontext" aria-label="Permalink to &quot;Kontext&quot;">​</a></h2><p>Messprotokolle (RPT) sind reine Textdateien, können aber in Summe groß werden und sind oft sehr ähnlich. Wenn Protokolle direkt als BLOB in der CR‑SQLite‑DB gespeichert würden, steigt die Sync‑Last erheblich (große <code>crsql_changes</code>‑Mengen, mehr I/O auf dem Hub).</p><p>Zusätzlich soll <strong>Offline‑Import</strong> möglich sein: Protokolle können lokal importiert werden, auch wenn der Hub kurzfristig nicht erreichbar ist.</p><h2 id="entscheidung" tabindex="-1">Entscheidung <a class="header-anchor" href="#entscheidung" aria-label="Permalink to &quot;Entscheidung&quot;">​</a></h2><p>FMB Log speichert Messprotokolle <strong>außerhalb der Datenbank</strong> in einem Hub‑Ordner <code>protocols/</code> als <strong>append‑only Packfiles</strong>:</p><ul><li>Protokoll‑Bytes werden <strong>zstd‑komprimiert</strong> (optional mit Dictionary, z. B. <code>rpt-v1.dict</code>).</li><li>Die komprimierten Bytes werden in ein Packfile geschrieben (Append).</li><li>In SQLite wird nur eine Referenz gespeichert (<code>measurement_protocols</code>): <ul><li><code>pack_file</code>, <code>pack_offset</code>, <code>pack_length</code> (Position im Packfile)</li><li><code>blake3</code> (32‑Byte‑BLOB; Integrität über komprimierte Bytes)</li><li><code>dict_id</code> (optional)</li></ul></li><li>Zusätzlich wird ein lokaler <strong>LRU‑Cache</strong> genutzt, um Protokolle offline verfügbar zu halten und wiederholtes Lesen zu beschleunigen.</li></ul><h2 id="offline‐import-hub-nicht-erreichbar" tabindex="-1">Offline‑Import (Hub nicht erreichbar) <a class="header-anchor" href="#offline‐import-hub-nicht-erreichbar" aria-label="Permalink to &quot;Offline‑Import (Hub nicht erreichbar)&quot;">​</a></h2><p>Wenn der Hub nicht erreichbar ist:</p><ul><li>das Protokoll wird <strong>lokal</strong> in den Cache geschrieben,</li><li>in der DB wird eine „ausstehende“ Referenz abgelegt (<code>pack_file=&#39;&#39;</code>/<code>pack_length=0</code>),</li><li>eine Outbox (<code>protocol_upload_outbox</code>) merkt sich Upload‑Aufgaben,</li><li>sobald der Hub wieder erreichbar ist, werden ausstehende Uploads automatisch nachgeholt.</li></ul><h2 id="alternativen-abgewogen" tabindex="-1">Alternativen (abgewogen) <a class="header-anchor" href="#alternativen-abgewogen" aria-label="Permalink to &quot;Alternativen (abgewogen)&quot;">​</a></h2><ol><li><strong>BLOB in SQLite (CR‑SQLite sync)</strong><ul><li><ul><li>sehr einfache Referenzierung</li></ul></li><li>− hohe Sync‑Last, langsamer auf Netzlaufwerk, größere Konfliktflächen</li></ul></li><li><strong>Eine Datei pro Protokoll</strong><ul><li><ul><li>einfaches Lesen</li></ul></li><li>− sehr viele kleine Dateien (Overhead, Scans/Indexing, SMB‑Performance)</li></ul></li><li><strong>Großes Archiv, bei jedem Insert repacken</strong><ul><li><ul><li>ggf. bessere Kompression</li></ul></li><li>− hoher Rewrite‑Aufwand; schlecht für parallele Clients</li></ul></li></ol><h2 id="konsequenzen" tabindex="-1">Konsequenzen <a class="header-anchor" href="#konsequenzen" aria-label="Permalink to &quot;Konsequenzen&quot;">​</a></h2><ul><li><strong>Integrität:</strong> Protokoll‑Integrität wird über BLAKE3 gesichert; Abweichungen werden beim Lesen erkannt.</li><li><strong>Backup:</strong> Hub‑Backups müssen <code>protocols/</code> enthalten (nicht nur die DB).</li><li><strong>Dictionary‑Training:</strong> Zstd‑Dictionaries können (optional) nachtrainiert werden, um Speicher/I/O weiter zu reduzieren.</li></ul>',15)])])}const p=i(o,[["render",l]]);export{g as __pageData,p as default};
